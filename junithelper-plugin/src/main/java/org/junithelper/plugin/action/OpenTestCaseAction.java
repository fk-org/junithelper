/* 
 * Copyright 2009-2010 junithelper.org. 
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied. See the License for the specific language 
 * governing permissions and limitations under the License. 
 */
package org.junithelper.plugin.action;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IActionDelegate;
import org.eclipse.ui.IEditorActionDelegate;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.ide.IDE;
import org.junithelper.plugin.Activator;
import org.junithelper.plugin.bean.ClassInfo;
import org.junithelper.plugin.bean.MethodInfo;
import org.junithelper.plugin.constant.Dialog;
import org.junithelper.plugin.constant.Message;
import org.junithelper.plugin.constant.Preference;
import org.junithelper.plugin.constant.StrConst;
import org.junithelper.plugin.io.PropertiesLoader;
import org.junithelper.plugin.page.PreferenceLoader;
import org.junithelper.plugin.util.FileResourceUtil;
import org.junithelper.plugin.util.ResourcePathUtil;
import org.junithelper.plugin.util.ResourceRefreshUtil;
import org.junithelper.plugin.util.SourceCodeParseUtil;
import org.junithelper.plugin.util.TestCaseGenerateUtil;
import org.junithelper.plugin.util.ThreadUtil;

/**
 * OpenTestCaseAction<br>
 * <br>
 * Open test case file.<br>
 * And if there were some unimplemented test methods, add them(enabled
 * generating test methods).<br>
 * 
 * @author Kazuhiro Sera <seratch@gmail.com>
 * @version 1.0
 */
public class OpenTestCaseAction extends Action implements IActionDelegate,
		IEditorActionDelegate {

	private ISelection selection = null;

	public IPreferenceStore store = null;

	public void run(IAction action) {
		if (store == null) {
			store = Activator.getDefault().getPreferenceStore();
		}
		PreferenceLoader pref = new PreferenceLoader(store);
		PropertiesLoader props = new PropertiesLoader(
				store.getString(Preference.lang));
		try {
			IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace()
					.getRoot();
			String projectName = null;
			String testTargetClassname = null;
			String testCaseFilename = null;
			String testCaseCreateFilepath = null;
			String testCaseResource = null;
			StructuredSelection structuredSelection = null;
			if (selection instanceof StructuredSelection) {
				// select in view(package explorer, navigator)
				structuredSelection = (StructuredSelection) selection;
			} else {
				// what to do?
			}
			if (structuredSelection != null && structuredSelection.size() == 0) {
				// required selecttion
				MessageDialog.openWarning(new Shell(),
						props.get(Dialog.Common.title),
						props.get(Dialog.Common.required));
				return;
			} else if (structuredSelection != null
					&& structuredSelection.size() > 1) {
				// select only one
				MessageDialog.openWarning(new Shell(),
						props.get(Dialog.Common.title),
						props.get(Dialog.Common.selectOneOnly));
				return;
			}
			// path started from project root
			String pathFromProjectRoot = ResourcePathUtil
					.getPathStartsFromProjectRoot(structuredSelection);
			// path started from project root
			// ex. /{projectName}/src/main/java/hoge/foo/var/TestTarget.java
			String[] dirArrFromProjectRoot = pathFromProjectRoot
					.split(StrConst.dirSep);
			// test case file create filesystem path
			String selected = StrConst.empty;
			int allDirLen = dirArrFromProjectRoot.length - 1;
			for (int i = 2; i < allDirLen; i++)
				selected += dirArrFromProjectRoot[i] + StrConst.dirSep;
			selected += dirArrFromProjectRoot[allDirLen]; // filename
			// current project name
			projectName = dirArrFromProjectRoot[1];
			// last element is test class file name
			String testTargetClassFilename = dirArrFromProjectRoot[dirArrFromProjectRoot.length - 1];
			testTargetClassname = testTargetClassFilename.replace(
					StrConst.javaFileExp, StrConst.empty);
			// test case name to open
			testCaseFilename = testTargetClassname + StrConst.suffixOfTestcase
					+ StrConst.javaFileExp;
			// get workspace path on os file system
			String projectRootPath = workspaceRoot.getLocation()
					+ StrConst.dirSep + projectName + StrConst.dirSep;
			if (testTargetClassname == null) {
				// required to select java file
				MessageDialog.openWarning(new Shell(),
						props.get(Dialog.Common.title),
						props.get(Dialog.Common.selectJavaFile));
			} else {
				testCaseResource = selected.replace(pref.commonSrcMainJavaDir,
						pref.commonTestMainJavaDir).replace(
						StrConst.javaFileExp,
						StrConst.suffixOfTestcase + StrConst.javaFileExp);
				testCaseCreateFilepath = projectRootPath
						+ selected.replace(pref.commonSrcMainJavaDir,
								pref.commonTestMainJavaDir).replace(
								StrConst.javaFileExp,
								StrConst.suffixOfTestcase
										+ StrConst.javaFileExp);
				// check already exist file
				File outputFile = new File(testCaseCreateFilepath);
				if (!outputFile.exists()) {
					// test class creating setting
					if (!pref.isTestClassGenEnabled) {
						MessageDialog
								.openInformation(
										new Shell(),
										props.get(Dialog.Common.title),
										props.get(Dialog.Common.notToCreateNewFilePreference));
						return;
					}
					// ----------------------------------------
					// create new file
					// ----------------------------------------
					String msg = props.get(Dialog.Common.notExist) + " ("
							+ testCaseFilename + ")" + StrConst.lineFeed
							+ props.get(Dialog.Common.confirmToCreateNewFile);
					if (testCaseFilename != null
							&& MessageDialog.openConfirm(new Shell(),
									props.get(Dialog.Common.title), msg)) {
						// create new file(java,dicon)
						new CreateNewTestCaseAction().run(action, selection);
					}
					return;
				}

				// ----------------------------------------
				// open test case
				// ----------------------------------------
				int retryCount = 0;
				IEditorPart editorPart = null;
				while (true) {
					try {
						IProject project = workspaceRoot
								.getProject(projectName);
						IFile testCaseFile = project.getFile(testCaseResource);
						String editorId = IDE.getEditorDescriptor(
								testCaseFile.getName()).getId();
						IWorkbenchPage page = PlatformUI.getWorkbench()
								.getActiveWorkbenchWindow().getActivePage();
						editorPart = IDE.openEditor(page, testCaseFile,
								editorId);
						editorPart.setFocus();

						// unimplemeneted test methods
						if (pref.isTestMethodGenEnabled) {
							IFile testTargetFile = project.getFile(selected);
							ClassInfo testClassWithNotImpledMethods = TestCaseGenerateUtil
									.getClassInfoWithUnimplementedTestMethods(
											testTargetClassname,
											testTargetFile, testCaseFile);
							List<MethodInfo> unimpledTestMethodNames = testClassWithNotImpledMethods.methods;
							String writeEncoding = FileResourceUtil
									.detectEncoding(testCaseFile);
							// need to add test method
							if (unimpledTestMethodNames.size() > 0) {
								List<String> lines = SourceCodeParseUtil
										.getLineList(testCaseFile);
								// generate test class
								StringBuilder sb = new StringBuilder();
								String CRLF = StrConst.carriageReturn
										+ StrConst.lineFeed;
								boolean isImportedTypesAdded = false;
								for (String line : lines) {
									if (line.equals("}")
											&& pref.isTestMethodGenEnabled) {
										for (MethodInfo testMethod : unimpledTestMethodNames) {
											if (testMethod.testMethodName == null
													|| testMethod.testMethodName
															.equals(StrConst.empty)) {
												continue;
											}
											if (pref.isTestMethodGenEnabledSupportJMockit) {
												sb.append(TestCaseGenerateUtil
														.getRequiredInstanceFieldsSourceForJMockitTestMethod(
																testMethod,
																testClassWithNotImpledMethods,
																testTargetClassname));
											}
											if (pref.isJUnitVersion4) {
												sb.append("\t@Test");
												sb.append(CRLF);
											}
											sb.append("\tpublic void ");
											sb.append(testMethod.testMethodName);
											sb.append("() throws Exception {");
											sb.append(CRLF);
											sb.append(StrConst.tab);
											sb.append(StrConst.tab);
											sb.append("// ");
											sb.append(props
													.get(Message.autoGenTodoMessage));
											sb.append(CRLF);
											if (pref.isTestMethodGenNotBlankEnabled) {
												String notBlankSourceCode = TestCaseGenerateUtil
														.getNotBlankTestMethodSource(
																testMethod,
																testClassWithNotImpledMethods,
																testTargetClassname);
												sb.append(notBlankSourceCode);
											}
											sb.append(StrConst.tab);
											sb.append("}");
											sb.append(CRLF);
											sb.append(CRLF);
										}
										sb.append("}");
										sb.append(CRLF);
										break;

									} else {
										sb.append(line);
										sb.append(CRLF);

										if (line.matches("^\\s*?import\\s+.+?")
												&& !isImportedTypesAdded
												&& pref.isTestMethodGenNotBlankEnabled) {
											List<String> importTypes = testClassWithNotImpledMethods.importList;
											for (String importType : importTypes) {
												if (importType.matches("//.+"))
													continue;
												sb.append("import ");
												sb.append(importType);
												sb.append(";");
												sb.append(CRLF);
											}
											isImportedTypesAdded = true;
										}
									}
								}
								String content = sb.toString();
								OutputStreamWriter testFileOSWriter = null;
								FileOutputStream fos = null;
								try {
									fos = new FileOutputStream(projectRootPath
											+ StrConst.dirSep
											+ testCaseResource);
									testFileOSWriter = new OutputStreamWriter(
											fos, writeEncoding);
									testFileOSWriter.write(content);
								} finally {
									FileResourceUtil.close(testFileOSWriter);
									FileResourceUtil.close(fos);
								}
							}

							// resource refresh
							if (!ResourceRefreshUtil.refreshLocal(null,
									projectName + StrConst.dirSep
											+ testCaseResource + "/..")) {
								MessageDialog
										.openWarning(
												new Shell(),
												props.get(Dialog.Common.title),
												props.get(Dialog.Common.resourceRefreshError));
								System.err.println("Resource refresh error!");

							} else {

								// open test case
								retryCount = 0;
								ThreadUtil.sleep(1500);
								while (true) {
									try {
										editorPart = IDE.openEditor(page,
												testCaseFile, editorId);
										if (editorPart == null)
											throw new NullPointerException();
										break;
									} catch (Exception e) {
										retryCount++;
										if (retryCount > 3)
											break;
										ThreadUtil.sleep(1500);
									}
								}
								editorPart.setFocus();
							}
						}
					} catch (Exception e) {
						retryCount++;
						if (retryCount > 10)
							break;
						e.printStackTrace();
						ThreadUtil.sleep(1500);
					}
					break;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Method to catch the event selection has been changed.
	 */
	public void selectionChanged(IAction action, ISelection selection) {
		this.selection = selection;
	}

	/**
	 * Required in IEditorActionDelegate(ex. Java editor)
	 */
	public void setActiveEditor(IAction action, IEditorPart targetEditor) {
	}

}
